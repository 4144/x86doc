<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>RDTSC—Read Time-Stamp Counter</title>
</head>
<body>
<h1 id="rdtsc-read-time-stamp-counter">RDTSC—Read Time-Stamp Counter</h1>
<table>
<tr>
	<td>Opcode*</td>
	<td>Instruction</td>
	<td>Op/En</td>
	<td>64-Bit Mode</td>
	<td>Compat/Leg Mode</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F 31</td>
	<td>RDTSC</td>
	<td>NP</td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Read time-stamp counter into EDX:EAX.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>NP</td>
	<td>NA</td>
	<td>NA</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Loads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)</p>
<p>The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See “Time Stamp Counter” in Chapter 17 of the <em>Intel® 64 and IA-32 Architectures Software</em> <em>Developer’s Manual, Volume 3B</em>, for specific details of the time stamp counter behavior.</p>
<p>When in protected or virtual 8086 mode, the time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the TSD flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDTSC instruction is always enabled.)</p>
<p>The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.</p>
<p>The RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed. If software requires RDTSC to be executed only after all previous instructions have completed locally, it can either use RDTSCP (if the processor supports that instruction) or execute the sequence LFENCE;RDTSC.</p>
<p>This instruction was introduced by the Pentium processor.</p>
<p>See “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p>
<h2 id="operation">Operation</h2>
<pre>IF (CR4.TSD = 0) or (CPL = 0) or (CR0.PE = 0)
  THEN EDX:EAX ← TimeStampCounter;
  ELSE (* CR4.TSD = 1 and (CPL = 1, 2, or 3) and CR0.PE = 1 *)
     #GP(0);
FI;
</pre>
<h2 id="flags-affected">Flags Affected</h2>
<p>None.</p>
<h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the TSD flag in register CR4 is set and the CPL is greater than 0.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the TSD flag in register CR4 is set.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="compatibility-mode-exceptions">Compatibility Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p>
<h2 id="64-bit-mode-exceptions">64-Bit Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p>
</body>
</html>
