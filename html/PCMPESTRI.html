<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>PCMPESTRI — Packed Compare Explicit Length Strings, Return Index</title>
</head>
<body>
<h1 id="pcmpestri---packed-compare-explicit-length-strings--return-index">PCMPESTRI — Packed Compare Explicit Length Strings, Return Index</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>66 0F 3A 61 /r imm8PCMPESTRI xmm1, xmm2/m128, imm8</td>
	<td>RMI</td>
	<td>V/V</td>
	<td>SSE4_2</td>
	<td>Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.</td>
</tr>
<tr>
	<td>VEX.128.66.0F3A.WIG 61 /r ib VPCMPESTRI xmm1, xmm2/m128, imm8</td>
	<td>RMI</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RMI</td>
	<td>ModRM:reg (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>imm8</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>The instruction compares and processes data from two string fragments based on the encoded value in the Imm8Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to the count register (ECX/RCX).</p>
<p>Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second</p>
<table>
<tr>
	<td>operand) which contains the data elements of the string (byte or word data). length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data. The length of each input is interpreted as being the absolute-value of the value in the length register. The absolutevalue computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8). The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8). Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:</td>
	<td>The second value is stored in an input</td>
</tr>
</table>
<p>CFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if absolute-value of EDX is &lt; 16 (8), reset otherwise SFlag - Set if absolute-value of EAX is &lt; 16 (8), reset otherwise OFlag - IntRes2[0]AFlag - Reset PFlag - Reset</p>
<h2 id="effective-operand-size">Effective Operand Size</h2>
<table>
<tr>
	<td>Operating mode/size</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Length 1</td>
	<td>Length 2</td>
	<td>Result</td>
</tr>
<tr>
	<td>16 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>EAX</td>
	<td>EDX</td>
	<td>ECX</td>
</tr>
<tr>
	<td>32 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>EAX</td>
	<td>EDX</td>
	<td>ECX</td>
</tr>
<tr>
	<td>64 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>EAX</td>
	<td>EDX</td>
	<td>ECX</td>
</tr>
<tr>
	<td>64 bit + REX.W</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>RAX</td>
	<td>RDX</td>
	<td>RCX</td>
</tr>
</table>
<h2 id="intel-c-c---compiler-intrinsic-equivalent-for-returning-index">Intel C/C++ Compiler Intrinsic Equivalent For Returning Index</h2>
<table>
<tr>
	<td>int</td>
	<td>_mm_cmpestri (__m128i a, int la, __m128i b, int lb, const int mode);</td>
</tr>
</table>
<h2 id="intel-c-c---compiler-intrinsics-for-reading-eflag-results">Intel C/C++ Compiler Intrinsics For Reading EFlag Results</h2>
<table>
<tr>
	<td>int</td>
	<td>_mm_cmpestra (__m128i a, int la, __m128i b, int lb, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpestrc (__m128i a, int la, __m128i b, int lb, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpestro (__m128i a, int la, __m128i b, int lb, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpestrs (__m128i a, int la, __m128i b, int lb, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpestrz (__m128i a, int la, __m128i b, int lb, const int mode);</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 4; additionally, this instruction does not cause #GP if the memory operand is not aligned to 16Byte boundary, and</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.L = 1. If VEX.vvvv != 1111B.</td>
</tr>
</table>
</body>
</html>
