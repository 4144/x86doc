<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>PMOVSX — Packed Move with Sign Extend</title>
</head>
<body>
<h1 id="pmovsx-packed-move-with-sign-extend">PMOVSX — Packed Move with Sign Extend</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>66 0f 38 20 /r PMOVSXBW <em>xmm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_1</td>
	<td>Sign extend 8 packed signed 8-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 8 packed signed 16-bit integers in <em>xmm1.</em></td>
</tr>
<tr>
	<td>66 0f 38 21 /r PMOVSXBD <em>xmm1, xmm2/m32</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_1</td>
	<td>Sign extend 4 packed signed 8-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 4 packed signed 32-bit integers in <em>xmm1.</em></td>
</tr>
<tr>
	<td>66 0f 38 22 /r PMOVSXBQ <em>xmm1, xmm2/m16</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_1</td>
	<td>Sign extend 2 packed signed 8-bit integers in the low 2 bytes of <em>xmm2/m16</em> to 2 packed signed 64-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>66 0f 38 23 /r PMOVSXWD<em> xmm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_1</td>
	<td>Sign extend 4 packed signed 16-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 4 packed signed 32-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>66 0f 38 24 /r PMOVSXWQ <em>xmm1, xmm2/m32</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_1</td>
	<td>Sign extend 2 packed signed 16-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 2 packed signed 64-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>66 0f 38 25 /r PMOVSXDQ<em> xmm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_1</td>
	<td>Sign extend 2 packed signed 32-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 2 packed signed 64-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.WIG 20 /r VPMOVSXBW <em>xmm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Sign extend 8 packed 8-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 8 packed 16-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.WIG 21 /r VPMOVSXBD <em>xmm1, xmm2/m32</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Sign extend 4 packed 8-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 4 packed 32-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.WIG 22 /r VPMOVSXBQ <em>xmm1, xmm2/m16</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Sign extend 2 packed 8-bit integers in the low 2 bytes of <em>xmm2/m16</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.WIG 23 /r VPMOVSXWD <em>xmm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Sign extend 4 packed 16-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 4 packed 32-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.WIG 24 /r VPMOVSXWQ <em>xmm1, xmm2/m32</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Sign extend 2 packed 16-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 2 packed 64-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.WIG 25 /r VPMOVSXDQ <em>xmm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Sign extend 2 packed 32-bit integers in the low 8 bytes of <em>xmm2/m64 </em>to 2 packed 64-bit integers in <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.256.66.0F38.WIG 20 /r VPMOVSXBW <em>ymm1, xmm2/m128</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Sign extend 16 packed 8-bit integers in <em>xmm2/m128 to 16 packed 16-bit integers in</em> <em>ymm1.</em></td>
</tr>
<tr>
	<td>VEX.256.66.0F38.WIG 21 /r VPMOVSXBD <em>ymm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Sign extend 8 packed 8-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 8 packed 32-bit integers in <em>ymm1</em>.</td>
</tr>
<tr>
	<td>VEX.256.66.0F38.WIG 22 /r VPMOVSXBQ <em>ymm1, xmm2/m32</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Sign extend 4 packed 8-bit integers in the low 4 bytes of <em>xmm2/m32</em> to 4 packed 64-bit integers in <em>ymm1</em>.</td>
</tr>
<tr>
	<td>VEX.256.66.0F38.WIG 23 /r VPMOVSXWD <em>ymm1, xmm2/m128</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Sign extend 8 packed 16-bit integers in the low 16 bytes of <em>xmm2/m128</em> to 8 packed 32bit integers in<em> ymm1</em>.</td>
</tr>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>VEX.256.66.0F38.WIG 24 /r VPMOVSXWQ <em>ymm1, xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Sign extend 4 packed 16-bit integers in the low 8 bytes of <em>xmm2/m64</em> to 4 packed 64-bit integers in <em>ymm1</em>.</td>
</tr>
<tr>
	<td>VEX.256.66.0F38.WIG 25 /r VPMOVSXDQ <em>ymm1, xmm2/m128</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Sign extend 4 packed 32-bit integers in the low 16 bytes of <em>xmm2/m128 </em>to 4 packed 64bit integers in <em>ymm1</em>.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Sign-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.256 encoded version: The destination register is YMM Register. Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p>
<h2 id="operation">Operation</h2>
<pre>PMOVSXBW
  DEST[15:0] ← SignExtend(SRC[7:0]);
  DEST[31:16] ← SignExtend(SRC[15:8]);
  DEST[47:32] ← SignExtend(SRC[23:16]);
  DEST[63:48] ← SignExtend(SRC[31:24]);
  DEST[79:64] ← SignExtend(SRC[39:32]);
  DEST[95:80] ← SignExtend(SRC[47:40]);
  DEST[111:96] ← SignExtend(SRC[55:48]);
  DEST[127:112] ← SignExtend(SRC[63:56]);
PMOVSXBD
  DEST[31:0] ← SignExtend(SRC[7:0]);
  DEST[63:32] ← SignExtend(SRC[15:8]);
  DEST[95:64] ← SignExtend(SRC[23:16]);
  DEST[127:96] ← SignExtend(SRC[31:24]);
PMOVSXBQ
  DEST[63:0] ← SignExtend(SRC[7:0]);
  DEST[127:64] ← SignExtend(SRC[15:8]);
PMOVSXWD
  DEST[31:0] ← SignExtend(SRC[15:0]);
  DEST[63:32] ← SignExtend(SRC[31:16]);
  DEST[95:64] ← SignExtend(SRC[47:32]);
  DEST[127:96] ← SignExtend(SRC[63:48]);
PMOVSXWQ
  DEST[63:0] ← SignExtend(SRC[15:0]);
  DEST[127:64] ← SignExtend(SRC[31:16]);
PMOVSXDQ
  DEST[63:0] ← SignExtend(SRC[31:0]);
  DEST[127:64] ← SignExtend(SRC[63:32]);
VPMOVSXBW (VEX.128 encoded version)
Packed_Sign_Extend_BYTE_to_WORD()
DEST[VLMAX-1:128] ← 0
VPMOVSXBD (VEX.128 encoded version)
Packed_Sign_Extend_BYTE_to_DWORD()
DEST[VLMAX-1:128] ← 0
VPMOVSXBQ (VEX.128 encoded version)
Packed_Sign_Extend_BYTE_to_QWORD()
DEST[VLMAX-1:128] ← 0
VPMOVSXWD (VEX.128 encoded version)
Packed_Sign_Extend_WORD_to_DWORD()
DEST[VLMAX-1:128] ← 0
VPMOVSXWQ (VEX.128 encoded version)
Packed_Sign_Extend_WORD_to_QWORD()
DEST[VLMAX-1:128] ← 0
VPMOVSXDQ (VEX.128 encoded version)
Packed_Sign_Extend_DWORD_to_QWORD()
DEST[VLMAX-1:128] ← 0
VPMOVSXBW (VEX.256 encoded version)
Packed_Sign_Extend_BYTE_to_WORD(DEST[127:0], SRC[63:0])
Packed_Sign_Extend_BYTE_to_WORD(DEST[255:128], SRC[127:64])
VPMOVSXBD (VEX.256 encoded version)
Packed_Sign_Extend_BYTE_to_DWORD(DEST[127:0], SRC[31:0])
Packed_Sign_Extend_BYTE_to_DWORD(DEST[255:128], SRC[63:32])
VPMOVSXBQ (VEX.256 encoded version)
Packed_Sign_Extend_BYTE_to_QWORD(DEST[127:0], SRC[15:0])
Packed_Sign_Extend_BYTE_to_QWORD(DEST[255:128], SRC[31:16])
VPMOVSXWD (VEX.256 encoded version)
Packed_Sign_Extend_WORD_to_DWORD(DEST[127:0], SRC[63:0])
Packed_Sign_Extend_WORD_to_DWORD(DEST[255:128], SRC[127:64])
VPMOVSXWQ (VEX.256 encoded version)
Packed_Sign_Extend_WORD_to_QWORD(DEST[127:0], SRC[31:0])
Packed_Sign_Extend_WORD_to_QWORD(DEST[255:128], SRC[63:32])
VPMOVSXDQ (VEX.256 encoded version)
Packed_Sign_Extend_DWORD_to_QWORD(DEST[127:0], SRC[63:0])
Packed_Sign_Extend_DWORD_to_QWORD(DEST[255:128], SRC[127:64])
</pre>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>(V)PMOVSXBW:</td>
	<td>__m128i _mm_ cvtepi8_epi16 ( __m128i a);</td>
</tr>
<tr>
	<td>VPMOVSXBW:</td>
	<td>__m256i _mm256_cvtepi8_epi16 ( __m128i a);</td>
</tr>
<tr>
	<td>(V)PMOVSXBD:</td>
	<td>__m128i _mm_ cvtepi8_epi32 ( __m128i a);</td>
</tr>
<tr>
	<td>VPMOVSXBD:</td>
	<td>__m256i _mm256_cvtepi8_epi32 ( __m128i a);</td>
</tr>
<tr>
	<td>(V)PMOVSXBQ:</td>
	<td>__m128i _mm_ cvtepi8_epi64 ( __m128i a);</td>
</tr>
<tr>
	<td>VPMOVSXBQ:</td>
	<td>__m256i _mm256_cvtepi8_epi64 ( __m128i a);</td>
</tr>
<tr>
	<td>(V)PMOVSXWD:</td>
	<td>__m128i _mm_ cvtepi16_epi32 ( __m128i a);</td>
</tr>
<tr>
	<td>VPMOVSXWD:</td>
	<td>__m256i _mm256_cvtepi16_epi32 ( __m128i a);</td>
</tr>
<tr>
	<td>(V)PMOVSXWQ:</td>
	<td>__m128i _mm_ cvtepi16_epi64 ( __m128i a);</td>
</tr>
<tr>
	<td>VPMOVSXWQ:</td>
	<td>__m256i _mm256_cvtepi16_epi64 ( __m128i a);</td>
</tr>
<tr>
	<td>(V)PMOVSXDQ:</td>
	<td>__m128i _mm_ cvtepi32_epi64 ( __m128i a);</td>
</tr>
<tr>
	<td>VPMOVSXDQ:</td>
	<td>__m256i _mm256_cvtepi32_epi64 ( __m128i a);</td>
</tr>
</table>
<h2 id="flags-affected">Flags Affected</h2>
<p>None.</p>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 5; additionally</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.L = 1. If VEX.vvvv != 1111B.</td>
</tr>
</table>
</body>
</html>
