<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>MOVHLPS— Move Packed Single-Precision Floating-Point Values High to Low</title>
</head>
<body>
<h1 id="movhlps-move-packed-single-precision-floating-point-values-high-to-low">MOVHLPS— Move Packed Single-Precision Floating-Point Values High to Low</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32-bit Mode</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F 12 /<em>r</em> MOVHLPS<em> xmm1, xmm2</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE</td>
	<td>Move two packed single-precision floatingpoint values from high quadword of <em>xmm2</em> to low quadword of <em>xmm1</em>.</td>
</tr>
<tr>
	<td>VEX.NDS.128.0F.WIG 12 /r VMOVHLPS <em>xmm1, xmm2, xmm3</em></td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Merge two packed single-precision floatingpoint values from high quadword of <em>xmm3</em> and low quadword of <em>xmm2</em>.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>RVM</td>
	<td>ModRM:reg (w)</td>
	<td>VEX.vvvv (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>This instruction cannot be used for memory to register moves. <strong>128-bit two-argument form:</strong> Moves two packed single-precision floating-point values from the high quadword of the second XMM argument (second operand) to the low quadword of the first XMM register (first argument). The high quadword of the destination operand is left unchanged. Bits (VLMAX-1:64) of the corresponding YMM destination register are unmodified. <strong>128-bit three-argument form</strong> Moves two packed single-precision floating-point values from the high quadword of the third XMM argument (third operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM argument (second operand) to the high quadword of the destination (first operand). Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p>
<p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15). If VMOVHLPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p>
<h2 id="operation">Operation</h2>
<pre>MOVHLPS (128-bit two-argument form)
DEST[63:0] ← SRC[127:64]
DEST[VLMAX-1:64] (Unmodified)
VMOVHLPS (128-bit three-argument form)
DEST[63:0] ← SRC2[127:64]
DEST[127:64] ← SRC1[127:64]
DEST[VLMAX-1:128] ← 0
</pre>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>MOVHLPS:</td>
	<td>__m128 _mm_movehl_ps(__m128 a, __m128 b)</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 7; additionally</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.L= 1.</td>
</tr>
</table>
</body>
</html>
