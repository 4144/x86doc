<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>INVLPG—Invalidate TLB Entry</title>
</head>
<body>
<h1 id="invlpg-invalidate-tlb-entry">INVLPG—Invalidate TLB Entry</h1>
<table>
<tr>
	<td>Opcode</td>
	<td>Instruction</td>
	<td>Op/En</td>
	<td>64-Bit Mode</td>
	<td>Compat/Leg Mode</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F 01/7</td>
	<td>INVLPG m</td>
	<td>M</td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Invalidate TLB Entry for page that contains m.</td>
</tr>
</table>
<p class="notes">Notes: * See the IA-32 Architecture Compatibility section below.</p><h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>M</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Invalidates (flushes) the translation lookaside buffer (TLB) entry specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes the TLB entry for that page.</p><p>The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must be 0 to execute this instruction.</p><p>The INVLPG instruction normally flushes the TLB entry only for the specified page; however, in some cases, it may flush more entries, even the entire TLB. The instruction is guaranteed to invalidates only TLB entries associated with the current PCID. (If PCIDs are disabled — CR4.PCIDE = 0 — the current PCID is 000H.) The instruction also invalidates any global TLB entries for the specified page, regardless of PCID.</p><p>For more details on operations that flush the TLB, see “MOV—Move to/from Control Registers” and Section 4.10.4.1, “Operations that Invalidate TLBs and Paging-Structure Caches,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.</p><p>This instruction’s operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.</p><h2 id="ia-32-architecture-compatibility">IA-32 Architecture Compatibility</h2>
<p>The INVLPG instruction is implementation dependent, and its function may be implemented differently on different families of Intel 64 or IA-32 processors. This instruction is not supported on IA-32 processors earlier than the Intel486 processor.</p><h2 id="operation">Operation</h2>
<pre>Flush(RelevantTLBEntries);
Continue; (* Continue execution *)
</pre><h2 id="flags-affected">Flags Affected</h2>
<p>None.</p><h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the current privilege level is not 0.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>Operand is a register. If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>Operand is a register. If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>The INVLPG instruction cannot be executed at the virtual-8086 mode.</td>
</tr>
</table>
<h2 id="64-bit-mode-exceptions">64-Bit Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the current privilege level is not 0.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>Operand is a register. If the LOCK prefix is used.</td>
</tr>
</table>
</body>
</html>
