<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>XBEGIN — Transactional Begin</title>
</head>
<body>
<h1 id="xbegin-transactional-begin">XBEGIN — Transactional Begin</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>C7 F8</td>
	<td>A</td>
	<td>V/V</td>
	<td>RTM</td>
	<td>Specifies the start of an RTM region. Provides a 16-bit relative XBEGIN rel16 which execution resumes following an RTM abort.</td>
</tr>
<tr>
	<td>C7 F8</td>
	<td>A</td>
	<td>V/V</td>
	<td>RTM</td>
	<td>Specifies the start of an RTM region. Provides a 32-bit relative XBEGIN rel32 which execution resumes following an RTM abort.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand2</td>
	<td>Operand3</td>
	<td>Operand4</td>
</tr>
<tr>
	<td>A</td>
	<td>Offset</td>
	<td>NA</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in transactional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execution. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort. On an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction.</p>
<h2 id="operation">Operation</h2>
<pre>XBEGIN
IF RTM_NEST_COUNT &lt; MAX_RTM_NEST_COUNT
  THEN
     RTM_NEST_COUNT++
     IF RTM_NEST_COUNT = 1 THEN
       IF 64-bit Mode
          THEN
               fallbackRIP ← RIP + SignExtend64(IMM)
                       (* RIP is instruction following XBEGIN instruction *)
             ELSE
               fallbackEIP ← EIP + SignExtend32(IMM)
                       (* EIP is instruction following XBEGIN instruction *)
       FI;
       IF (64-bit mode)
          THEN IF (fallbackRIP is not canonical)
             THEN #GP(0)
          FI;
          ELSE IF (fallbackEIP outside code segment limit)
             THEN #GP(0)
          FI;
       FI;
       RTM_ACTIVE ← 1
       Enter RTM Execution (* record register state, start tracking memory state*)
     FI; (* RTM_NEST_COUNT = 1 *)
  ELSE (* RTM_NEST_COUNT = MAX_RTM_NEST_COUNT *)
     GOTO RTM_ABORT_PROCESSING
FI;
(* For any RTM abort condition encountered during RTM execution *)
RTM_ABORT_PROCESSING:
  Restore architectural register state
  Discard memory updates performed in transaction
  Update EAX with status
  RTM_NEST_COUNT ← 0
  RTM_ACTIVE ← 0
  IF 64-bit mode
     THEN
       RIP ← fallbackRIP
     ELSE
       EIP ← fallbackEIP
  FI;
END
</pre>
<h2 id="flags-affected">Flags Affected</h2>
<p>None</p>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>XBEGIN:</td>
	<td>unsigned int _xbegin( void );</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None</p>
<h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>CPUID.(EAX=7, ECX=0):RTM[bit 11]=0. If LOCK prefix is used.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>If the fallback address is outside the CS segment.</td>
</tr>
</table>
<h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the fallback address is outside the address space 0000H and FFFFH.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>CPUID.(EAX=7, ECX=0):RTM[bit 11]=0. If LOCK prefix is used.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the fallback address is outside the address space 0000H and FFFFH.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>CPUID.(EAX=7, ECX=0):RTM[bit 11]=0. If LOCK prefix is used.</td>
</tr>
</table>
<h2 id="compatibility-mode-exceptions">Compatibility Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p>
<h2 id="64-bit-mode-exceptions">64-bit Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>CPUID.(EAX=7, ECX=0):RTM[bit 11] = 0. If LOCK prefix is used.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>XCHG—Exchange Register/Memory with Register</td>
</tr>
<tr>
	<td>Opcode</td>
	<td>Description Leg Mode</td>
</tr>
<tr>
	<td>90+rw</td>
	<td>Exchange r16 with AX.</td>
</tr>
<tr>
	<td>90+rw</td>
	<td>Exchange AX with r16.</td>
</tr>
<tr>
	<td>90+rd</td>
	<td>Exchange r32 with EAX.</td>
</tr>
<tr>
	<td>REX.W + 90+rd</td>
	<td>Exchange r64 with RAX.</td>
</tr>
<tr>
	<td>90+rd</td>
	<td>Exchange EAX with r32.</td>
</tr>
<tr>
	<td>REX.W + 90+rd</td>
	<td>Exchange RAX with r64.</td>
</tr>
<tr>
	<td>86 /r</td>
	<td>Exchange r8 (byte register) with byte from r/m8.</td>
</tr>
<tr>
	<td>REX + 86 /r</td>
	<td>Exchange r8 (byte register) with byte from r/m8.</td>
</tr>
<tr>
	<td>86 /r</td>
	<td>Exchange byte from r/m8 with r8 (byte register).</td>
</tr>
<tr>
	<td>REX + 86 /r</td>
	<td>Exchange byte from r/m8 with r8 (byte register).</td>
</tr>
<tr>
	<td>87 /r</td>
	<td>Exchange r16 with word from r/m16.</td>
</tr>
<tr>
	<td>87 /r</td>
	<td>Exchange word from r/m16 with r16.</td>
</tr>
<tr>
	<td>87 /r</td>
	<td>Exchange r32 with doubleword from r/m32.</td>
</tr>
<tr>
	<td>REX.W + 87 /r</td>
	<td>Exchange r64 with quadword from r/m64.</td>
</tr>
<tr>
	<td>87 /r</td>
	<td>Exchange doubleword from r/m32 with r32.</td>
</tr>
<tr>
	<td>REX.W + 87 /r</td>
	<td>Exchange quadword from r/m64 with r64.</td>
</tr>
</table>
<p class="notes">Notes: * In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.</p>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>O</td>
	<td>AX/EAX/RAX (r, w)</td>
	<td>opcode + rd (r, w)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>O</td>
	<td>opcode + rd (r, w)</td>
	<td>AX/EAX/RAX (r, w)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>MR</td>
	<td>ModRM:r/m (r, w)</td>
	<td>ModRM:reg (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Exchanges the contents of the destination (first) and source (second) operands. The operands can be two generalpurpose registers or a register and a memory location. If a memory operand is referenced, the processor’s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.)</p>
<p>This instruction is useful for implementing semaphores or similar data structures for process synchronization. (See “Bus Locking” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information on bus locking.)</p>
<p>The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation">Operation</h2>
<pre>TEMP ← DEST;
DEST ← SRC;
SRC ← TEMP;
</pre>
<h2 id="flags-affected">Flags Affected</h2>
<p>None.</p>
<h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If either operand is in a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a NULL segment selector.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used but the destination is not a memory operand.</td>
</tr>
</table>
<h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#GP</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td>
</tr>
<tr>
	<td>#SS</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used but the destination is not a memory operand.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used but the destination is not a memory operand.</td>
</tr>
</table>
<h2 id="compatibility-mode-exceptions">Compatibility Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p>
<h2 id="64-bit-mode-exceptions">64-Bit Mode Exceptions</h2>
<table>
<tr>
	<td>#SS(0)</td>
	<td>If a memory address referencing the SS segment is in a non-canonical form.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>If the memory address is in a non-canonical form.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used but the destination is not a memory operand.</td>
</tr>
</table>
</body>
</html>
