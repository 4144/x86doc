<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>PCMPISTRM — Packed Compare Implicit Length Strings, Return Mask</title>
</head>
<body>
<h1 id="pcmpistrm---packed-compare-implicit-length-strings--return-mask">PCMPISTRM — Packed Compare Implicit Length Strings, Return Mask</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>66 0F 3A 62 /r imm8PCMPISTRM xmm1, xmm2/m128, imm8</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_2</td>
	<td>Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.</td>
</tr>
<tr>
	<td>VEX.128.66.0F3A.WIG 62 /r ib VPCMPISTRM xmm1, xmm2/m128, imm8</td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>imm8</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask stored to XMM0.</p>
<p>Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which</p>
<table>
<tr>
	<td>contains the data elements of the string (byte or word data). A byte/word is considered valid only if it has a lower index than the least significant null (The least significant null byte/word is also considered invalid.) The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0. Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:</td>
	<td>Each input byte/word is augmented with a</td>
</tr>
</table>
<p>CFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if any byte/word of xmm2/mem128 is null, reset otherwise SFlag - Set if any byte/word of xmm1 is null, reset otherwise OFlag - IntRes2[0]AFlag - Reset PFlag - Reset Note: In VEX.128 encoded versions, bits (VLMAX-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p>
<h2 id="effective-operand-size">Effective Operand Size</h2>
<table>
<tr>
	<td>Operating mode/size</td>
	<td>Operand1</td>
	<td>Operand 2</td>
	<td>Result</td>
</tr>
<tr>
	<td>16 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>XMM0</td>
</tr>
<tr>
	<td>32 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>XMM0</td>
</tr>
<tr>
	<td>64 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>XMM0</td>
</tr>
<tr>
	<td>64 bit + REX.W</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>XMM0</td>
</tr>
</table>
<h2 id="intel-c-c---compiler-intrinsic-equivalent-for-returning-mask">Intel C/C++ Compiler Intrinsic Equivalent For Returning Mask</h2>
<p>__m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);</p>
<h2 id="intel-c-c---compiler-intrinsics-for-reading-eflag-results">Intel C/C++ Compiler Intrinsics For Reading EFlag Results</h2>
<table>
<tr>
	<td>int</td>
	<td>_mm_cmpistra (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistrc (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistro (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistrs (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistrz (__m128i a, __m128i b, const int mode);</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 4; additionally, this instruction does not cause #GP if the memory operand is not aligned to 16Byte boundary, and</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.L = 1. If VEX.vvvv != 1111B.</td>
</tr>
</table>
</body>
</html>
