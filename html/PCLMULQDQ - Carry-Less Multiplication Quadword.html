<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>PCLMULQDQ - Carry-Less Multiplication Quadword</title>
</head>
<body>
<h1 id="pclmulqdq---carry-less-multiplication-quadword">PCLMULQDQ - Carry-Less Multiplication Quadword</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>66 0F 3A 44 /r ib PCLMULQDQ xmm1, xmm2/m128, imm8</td>
	<td>RMI</td>
	<td>V/V</td>
	<td>CLMUL</td>
	<td>Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128,stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.</td>
</tr>
<tr>
	<td>VEX.NDS.128.66.0F3A.WIG 44 /r ib VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8</td>
	<td>RVMI</td>
	<td>V/V</td>
	<td>Both CLMUL and AVX flags</td>
	<td>Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128,stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand2</td>
	<td>Operand3</td>
	<td>Operand4</td>
</tr>
<tr>
	<td>RMI</td>
	<td>ModRM:reg (r, w)</td>
	<td>ModRM:r/m (r)</td>
	<td>imm8</td>
	<td>NA</td>
</tr>
<tr>
	<td>RVMI</td>
	<td>ModRM:reg (w)</td>
	<td>VEX.vvvv (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>imm8</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to Table 4-10, other bits of the immediate byte are ignored.</p>
<table>
<tr>
	<td>Table 4-10.</td>
	<td>PCLMULQDQ Quadword Selection of Immediate Byte PCLMULQDQ Operation CL_MUL( SRC21[63:0], SRC1[63:0] )CL_MUL( SRC2[63:0], SRC1[127:64] )CL_MUL( SRC2[127:64], SRC1[63:0] )CL_MUL( SRC2[127:64], SRC1[127:64] )</td>
</tr>
</table>
<p class="notes">Notes: 1. SRC2 denotes the second source operand, which can be a register or memory; SRC1 denotes the first source and destination operand.</p>
<p>The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p>
<p>Compilers and assemblers may implement the following pseudo-op syntax to simply programming and emit the required encoding for Imm8.</p>
<table>
<tr>
	<td>Table 4-11.</td>
	<td>Pseudo-Op and PCLMULQDQ Implementation Imm8 Encoding 0000_0000B 0000_0001B 0001_0000B 0001_0001B</td>
</tr>
</table>
<h2 id="operation">Operation</h2>
<pre>PCLMULQDQ
IF (Imm8[0] = 0 )
  THEN
     TEMP1 ← SRC1 [63:0];
  ELSE
     TEMP1 ← SRC1 [127:64];
FI
IF (Imm8[4] = 0 )
  THEN
     TEMP2 ← SRC2 [63:0];
  ELSE
     TEMP2 ← SRC2 [127:64];
FI
For i = 0 to 63 {
  TmpB [ i ] ← (TEMP1[ 0 ] and TEMP2[ i ]);
  For j = 1 to i {
     TmpB [ i ] ← TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i - j ])
  }
  DEST[ i ] ← TmpB[ i ];
}
For i = 64 to 126 {
  TmpB [ i ] ← 0;
  For j = i - 63 to 63 {
     TmpB [ i ] ← TmpB [ i ] xor (TEMP1[ j ] and TEMP2[ i - j ])
  }
  DEST[ i ] ← TmpB[ i ];
}
DEST[127] ← 0;
DEST[VLMAX-1:128] (Unmodified)
VPCLMULQDQ
IF (Imm8[0] = 0 )
  THEN
     TEMP1 ← SRC1 [63:0];
  ELSE
     TEMP1 ← SRC1 [127:64];
FI
IF (Imm8[4] = 0 )
  THEN
     TEMP2 ← SRC2 [63:0];
  ELSE
     TEMP2 ← SRC2 [127:64];
FI
For i = 0 to 63 {
  TmpB [ i ] ← (TEMP1[ 0 ] and TEMP2[ i ]);
  For j = 1 to i {
     TmpB [i] ← TmpB [i] xor (TEMP1[ j ] and TEMP2[ i - j ])
  }
  DEST[i] ← TmpB[i];
}
For i = 64 to 126 {
  TmpB [ i ] ← 0;
  For j = i - 63 to 63 {
     TmpB [i] ← TmpB [i] xor (TEMP1[ j ] and TEMP2[ i - j ])
  }
  DEST[i] ← TmpB[i];
}
DEST[VLMAX-1:127] ← 0;
</pre>
<h2 id="intel-c-c---compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>(V)PCLMULQDQ:</td>
	<td>__m128i</td>
	<td>_mm_clmulepi64_si128 (__m128i, __m128i, const int)</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 4.</p>
</body>
</html>
