<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>SGDT—Store Global Descriptor Table Register</title>
</head>
<body>
<h1 id="sgdt-store-global-descriptor-table-register">SGDT—Store Global Descriptor Table Register</h1>
<table>
<tr>
	<td>Opcode*</td>
	<td>Instruction</td>
	<td>Op/En</td>
	<td>64-Bit Mode</td>
	<td>Compat/Leg Mode</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F 01 /0</td>
	<td>SGDT m</td>
	<td>M</td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Store GDTR to m.</td>
</tr>
</table>
<p class="notes">Notes: * See IA-32 Architecture Compatibility section below.</p>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>M</td>
	<td>ModRM:r/m (w)</td>
	<td>NA</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location.</p>
<p>In legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in bytes 3-5, and byte 6 is zero-filled. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.</p>
<p>In IA-32e mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.</p>
<p>SGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated. See “LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3,Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, for information on loading the GDTR and IDTR.</p>
<h2 id="ia-32-architecture-compatibility">IA-32 Architecture Compatibility</h2>
<p>The 16-bit form of the SGDT is compatible with the Intel 286 processor if the upper 8 bits are not referenced. The Intel 286 processor fills these bits with 1s; the Pentium 4, Intel Xeon, P6 processor family, Pentium, Intel486, and Intel386™ processors fill these bits with 0s.</p>
<h2 id="operation">Operation</h2>
<pre>IF instruction is SGDT
     IF OperandSize = 16
       THEN
          DEST[0:15] ← GDTR(Limit);
          DEST[16:39] ← GDTR(Base); (* 24 bits of base address stored *)
          DEST[40:47] ← 0;
       ELSE IF (32-bit Operand Size)
          DEST[0:15] ← GDTR(Limit);
          DEST[16:47] ← GDTR(Base); (* Full 32-bit base address stored *)
          FI;
       ELSE (* 64-bit Operand Size *)
          DEST[0:15] ← GDTR(Limit);
          DEST[16:79] ← GDTR(Base); (* Full 64-bit base address stored *)
     FI;
FI;
</pre>
<h2 id="flags-affected">Flags Affected</h2>
<p>None.</p>
<h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>If the destination operand is a register. If the LOCK prefix is used.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>If the destination is located in a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td>
</tr>
</table>
<h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>If the destination operand is a register. If the LOCK prefix is used.</td>
</tr>
<tr>
	<td>#GP</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td>
</tr>
<tr>
	<td>#SS</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<table>
<tr>
	<td>#UD</td>
	<td>If the destination operand is a register. If the LOCK prefix is used.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made.</td>
</tr>
</table>
<h2 id="compatibility-mode-exceptions">Compatibility Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p>
<h2 id="64-bit-mode-exceptions">64-Bit Mode Exceptions</h2>
<table>
<tr>
	<td>#SS(0)</td>
	<td>If a memory address referencing the SS segment is in a non-canonical form.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the destination operand is a register. If the LOCK prefix is used.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>If the memory address is in a non-canonical form.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td>
</tr>
</table>
</body>
</html>
