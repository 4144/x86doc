<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>FLD—Load Floating Point Value</title>
</head>
<body>
<h1 id="fld-load-floating-point-value">FLD—Load Floating Point Value</h1>
<table>
<tr>
	<td>Opcode</td>
	<td>Instruction</td>
	<td>64-Bit Mode</td>
	<td>Compat/Leg Mode</td>
	<td>Description</td>
</tr>
<tr>
	<td>D9 /0</td>
	<td>FLD <em>m32fp</em></td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Push <em>m32fp</em> onto the FPU register stack.</td>
</tr>
<tr>
	<td>DD /0</td>
	<td>FLD <em>m64fp</em></td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Push <em>m64fp</em> onto the FPU register stack.</td>
</tr>
<tr>
	<td>DB /5</td>
	<td>FLD <em>m80fp</em></td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Push <em>m80fp</em> onto the FPU register stack.</td>
</tr>
<tr>
	<td>D9 C0+i</td>
	<td>FLD ST(i)</td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Push ST(i) onto the FPU register stack.</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, doubleprecision, or double extended-precision floating-point format. If the source operand is in single-precision or double-precision floating-point format, it is automatically converted to the double extended-precision floatingpoint format before being pushed on the stack.</p>
<p>The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.</p>
<p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p>
<h2 id="operation">Operation</h2>
<pre>IF SRC is ST(i)
  THEN
     temp ← ST(i);
FI;
TOP ← TOP − 1;
IF SRC is memory-operand
  THEN
     ST(0) ← ConvertToDoubleExtendedPrecisionFP(SRC);
  ELSE (* SRC is ST(i) *)
     ST(0) ← temp;
FI;
</pre>
<h2 id="fpu-flags-affected">FPU Flags Affected</h2>
<table>
<tr>
	<td>C1</td>
	<td>Set to 1 if stack overflow occurred; otherwise, set to 0.</td>
</tr>
<tr>
	<td>C0, C2, C3</td>
	<td>Undefined.</td>
</tr>
</table>
<h2 id="floating-point-exceptions">Floating-Point Exceptions</h2>
<table>
<tr>
	<td>#IS</td>
	<td>Stack underflow or overflow occurred.</td>
</tr>
<tr>
	<td>#IA</td>
	<td>Source operand is an SNaN. Does not occur if the source operand is in double extended-precision floating-point format (FLD m80fp or FLD ST(i)).</td>
</tr>
<tr>
	<td>#D</td>
	<td>Source operand is a denormal value. Does not occur if the source operand is in double extended-precision floating-point format.</td>
</tr>
</table>
<h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If destination is located in a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>CR0.EM[bit 2] or CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#GP</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td>
</tr>
<tr>
	<td>#SS</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>CR0.EM[bit 2] or CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>CR0.EM[bit 2] or CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
<h2 id="compatibility-mode-exceptions">Compatibility Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p>
<h2 id="64-bit-mode-exceptions">64-Bit Mode Exceptions</h2>
<table>
<tr>
	<td>#SS(0)</td>
	<td>If a memory address referencing the SS segment is in a non-canonical form.</td>
</tr>
<tr>
	<td>#GP(0)</td>
	<td>If the memory address is in a non-canonical form.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>CR0.EM[bit 2] or CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#MF</td>
	<td>If there is a pending x87 FPU exception.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#AC(0)</td>
	<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If the LOCK prefix is used.</td>
</tr>
</table>
</body>
</html>
