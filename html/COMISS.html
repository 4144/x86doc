<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS</title>
</head>
<body>
<h1 id="comiss-compare-scalar-ordered-single-precision-floating-point-values-and-set-eflags">COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32-bit Mode</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F 2F /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE</td>
	<td>Compare low single-precision floating-point COMISS xmm1, xmm2/m32the EFLAGS flags accordingly.</td>
</tr>
<tr>
	<td>VEX.LIG.0F.WIG 2F /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Compare low single precision floating-point VCOMISS xmm1, xmm2/m32the EFLAGS flags accordingly.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that -0.0 is equal to +0.0.</p>
<p>Operand 1 is an XMM register; Operand 2 can be an XMM register or a 32 bit memory location.</p>
<p>The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid numeric exception only if a source operand is an SNaN.</p>
<p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p>
<p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15). Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p>
<h2 id="operation">Operation</h2>
<pre>RESULT ← OrderedCompare(SRC1[31:0] <> SRC2[31:0]) {
(* Set EFLAGS *) CASE (RESULT) OF
  UNORDERED:
  GREATER_THAN:
  LESS_THAN:
  EQUAL:
ESAC;
OF,AF,SF ← 0; }
</pre>
<h2 id="intel-c-c---compiler-intrinsic-equivalents">Intel C/C++ Compiler Intrinsic Equivalents</h2>
<p>int _mm_comieq_ss (__m128 a, __m128 b)int _mm_comilt_ss (__m128 a, __m128 b)int _mm_comile_ss (__m128 a, __m128 b)int _mm_comigt_ss (__m128 a, __m128 b)int _mm_comige_ss (__m128 a, __m128 b)int _mm_comineq_ss (__m128 a, __m128 b)</p>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>Invalid (if SNaN or QNaN operands), Denormal.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 3; additionally</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.vvvv != 1111B.</td>
</tr>
</table>
</body>
</html>
