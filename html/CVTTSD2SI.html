<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>CVTTSD2SI—Convert with Truncation Scalar Double-Precision FP Value to Signed Integer</title>
</head>
<body>
<h1 id="cvttsd2si-convert-with-truncation-scalar-double-precision-fp-value-to-signed-integer">CVTTSD2SI—Convert with Truncation Scalar Double-Precision FP Value to Signed Integer</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32-bit Mode</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>F2 0F 2C /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Convert one double-precision floating-point CVTTSD2SI r32, xmm/m64 doubleword integer in r32 using truncation.</td>
</tr>
<tr>
	<td>F2 REX.W 0F 2C /r</td>
	<td>RM</td>
	<td>V/N.E.</td>
	<td>SSE2</td>
	<td>Convert one double precision floating-point CVTTSD2SI r64, xmm/m64 integer in r64 using truncation.</td>
</tr>
<tr>
	<td>VEX.LIG.F2.0F.W0 2C /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Convert one double-precision floating-point VCVTTSD2SI r32, xmm1/m64 doubleword integer in r32 using truncation.</td>
</tr>
<tr>
	<td>VEX.LIG.F2.0F.W1 2C /r</td>
	<td>RM</td>
	<td>V/N.E.1</td>
	<td>AVX</td>
	<td>Convert one double precision floating-point VCVTTSD2SI r64, xmm1/m64 quadword integer in r64 using truncation.</td>
</tr>
</table>
<p class="notes">Notes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.</p>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register. When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H) is returned. Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits. Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p>
<h2 id="operation">Operation</h2>
<pre>IF 64-Bit Mode and OperandSize = 64
  THEN
     DEST[63:0] ← Convert_Double_Precision_Floating_Point_To_
              Integer64_Truncate(SRC[63:0]);
  ELSE
     DEST[31:0] ← Convert_Double_Precision_Floating_Point_To_
             Integer32_Truncate(SRC[63:0]);
FI;
</pre>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<p>int _mm_cvttsd_si32(__m128d a) __int64 _mm_cvttsd_si64(__m128d a)</p>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>Invalid, Precision.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 3; additionally</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.vvvv != 1111B.</td>
</tr>
</table>
</body>
</html>
