<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>PSRAW/PSRAD—Shift Packed Data Right Arithmetic</title>
</head>
<body>
<h1 id="psraw-psrad-shift-packed-data-right-arithmetic">PSRAW/PSRAD—Shift Packed Data Right Arithmetic</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F E1 /r1PSRAW mm, mm/m64</td>
	<td>RM</td>
	<td>V/V</td>
	<td>MMX</td>
	<td>Shift words in mm right by mm/m64 while shifting in sign bits.</td>
</tr>
<tr>
	<td>66 0F E1 /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Shift words in xmm1 right by xmm2/m128PSRAW xmm1, xmm2/m128</td>
</tr>
<tr>
	<td>0F 71 /4 ib1</td>
	<td>MI</td>
	<td>V/V</td>
	<td>MMX</td>
	<td>Shift words in mm right by imm8 while shifting PSRAW mm, imm8</td>
</tr>
<tr>
	<td>66 0F 71 /4 ib</td>
	<td>MI</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Shift words in xmm1 right by imm8 while PSRAW xmm1, imm8</td>
</tr>
<tr>
	<td>0F E2 /r1PSRAD mm, mm/m64</td>
	<td>RM</td>
	<td>V/V</td>
	<td>MMX</td>
	<td>Shift doublewords in mm right by mm/m64while shifting in sign bits.</td>
</tr>
<tr>
	<td>66 0F E2 /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Shift doubleword in xmm1 right by xmm2PSRAD xmm1, xmm2/m128</td>
</tr>
<tr>
	<td>0F 72 /4 ib1</td>
	<td>MI</td>
	<td>V/V</td>
	<td>MMX</td>
	<td>Shift doublewords in mm right by imm8 while PSRAD mm, imm8</td>
</tr>
<tr>
	<td>66 0F 72 /4 ib</td>
	<td>MI</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Shift doublewords in xmm1 right by imm8PSRAD xmm1, imm8</td>
</tr>
<tr>
	<td>VEX.NDS.128.66.0F.WIG E1 /r</td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Shift words in xmm2 right by amount specified VPSRAW xmm1, xmm2, xmm3/m128</td>
</tr>
<tr>
	<td>VEX.NDD.128.66.0F.WIG 71 /4 ib</td>
	<td>VMI</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Shift words in xmm2 right by imm8 while VPSRAW xmm1, xmm2, imm8</td>
</tr>
<tr>
	<td>VEX.NDS.128.66.0F.WIG E2 /r</td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Shift doublewords in xmm2 right by amount VPSRAD xmm1, xmm2, xmm3/m128bits.</td>
</tr>
<tr>
	<td>VEX.NDD.128.66.0F.WIG 72 /4 ib</td>
	<td>VMI</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Shift doublewords in xmm2 right by imm8VPSRAD xmm1, xmm2, imm8</td>
</tr>
<tr>
	<td>VEX.NDS.256.66.0F.WIG E1 /r</td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Shift words in ymm2 right by amount specified VPSRAW ymm1, ymm2, xmm3/m128</td>
</tr>
<tr>
	<td>VEX.NDD.256.66.0F.WIG 71 /4 ib</td>
	<td>VMI</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Shift words in ymm2 right by imm8 while VPSRAW ymm1, ymm2, imm8</td>
</tr>
<tr>
	<td>VEX.NDS.256.66.0F.WIG E2 /r</td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Shift doublewords in ymm2 right by amount VPSRAD ymm1, ymm2, xmm3/m128bits.</td>
</tr>
<tr>
	<td>VEX.NDD.256.66.0F.WIG 72 /4 ib</td>
	<td>VMI</td>
	<td>V/V</td>
	<td>AVX2</td>
	<td>Shift doublewords in ymm2 right by imm8VPSRAD ymm1, ymm2, imm8</td>
</tr>
</table>
<p class="notes">Notes: 1. See note in Section 2.4, “Instruction Exception Specification” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A and Section 22.25.3, “Exception Conditions of Legacy SIMD Instructions Operating on MMX Registers” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.</p>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (r, w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>MI</td>
	<td>ModRM:r/m (r, w)</td>
	<td>imm8</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>RVM</td>
	<td>ModRM:reg (w)</td>
	<td>VEX.vvvv (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
</tr>
<tr>
	<td>VMI</td>
	<td>VEX.vvvv (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>imm8</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Shifts the bits in the individual data elements (words or doublewords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words) or 31 (for doublewords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-14 gives an example of shifting words in a 64-bit operand.)</p>
<p>Pre-Shift</p>
<table>
<tr>
	<td>X3</td>
	<td>X2X2 >> COUNT</td>
	<td>X1X1 >> COUNT</td>
	<td>X0DEST Shift Right with Sign Extension X0 >> COUNT DEST PSRAW and PSRAD Instruction Operation Using a 64-bit Operand</td>
</tr>
</table>
<p>Note that only the first 64-bits of a 128-bit count operand are checked to compute the count. If the second source operand is a memory address, 128 bits are loaded.</p>
<p>The (V)PSRAW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand, and the (V)PSRAD instruction shifts each of the doublewords in the destination operand.</p>
<p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p>
<p>Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location. 128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. VEX.128 encoded version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate.</p>
<p>Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /4), VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.</p>
<h2 id="operation">Operation</h2>
<pre>PSRAW (with 64-bit operand)
  IF (COUNT > 15)
     THEN COUNT ← 16;
  FI;
  DEST[15:0] ← SignExtend(DEST[15:0] >> COUNT);
  (* Repeat shift operation for 2nd and 3rd words *)
  DEST[63:48] ← SignExtend(DEST[63:48] >> COUNT);
PSRAD (with 64-bit operand)
  IF (COUNT > 31)
     THEN COUNT ← 32;
  FI;
  DEST[31:0] ← SignExtend(DEST[31:0] >> COUNT);
  DEST[63:32] ← SignExtend(DEST[63:32] >> COUNT);
PSRAW (with 128-bit operand)
  COUNT ← COUNT_SOURCE[63:0];
  IF (COUNT > 15)
     THEN COUNT ← 16;
  FI;
  DEST[15:0]
  (* Repeat shift operation for 2nd through 7th words *)
  DEST[127:112] ← SignExtend(DEST[127:112] >> COUNT);
PSRAD (with 128-bit operand)
  COUNT ← COUNT_SOURCE[63:0];
  IF (COUNT > 31)
     THEN COUNT ← 32;
  FI;
  DEST[31:0]
  (* Repeat shift operation for 2nd and 3rd doublewords *)
  DEST[127:96] ← SignExtend(DEST[127:96] >>COUNT);
PSRAW (xmm, xmm, xmm/m128)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_WORDS(DEST, SRC)
DEST[VLMAX-1:128] (Unmodified)
PSRAW (xmm, imm8)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_WORDS(DEST, imm8)
DEST[VLMAX-1:128] (Unmodified)
VPSRAW (xmm, xmm, xmm/m128)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_WORDS(SRC1, SRC2)
DEST[VLMAX-1:128] ← 0
VPSRAW (xmm, imm8)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_WORDS(SRC1, imm8)
DEST[VLMAX-1:128] ← 0
PSRAD (xmm, xmm, xmm/m128)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_DWORDS(DEST, SRC)
DEST[VLMAX-1:128] (Unmodified)
PSRAD (xmm, imm8)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_DWORDS(DEST, imm8)
DEST[VLMAX-1:128] (Unmodified)
VPSRAD (xmm, xmm, xmm/m128)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_DWORDS(SRC1, SRC2)
DEST[VLMAX-1:128] ← 0
VPSRAD (xmm, imm8)
DEST[127:0] ← ARITHMETIC_RIGHT_SHIFT_DWORDS(SRC1, imm8)
DEST[VLMAX-1:128] ← 0
VPSRAW (ymm, ymm, xmm/m128)
DEST[255:0] ← ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1, SRC2)
VPSRAW (ymm, imm8)
DEST[255:0] ← ARITHMETIC_RIGHT_SHIFT_WORDS_256b(SRC1, imm8)
VPSRAD (ymm, ymm, xmm/m128)
DEST[255:0] ← ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1, SRC2)
VPSRAD (ymm, imm8)
DEST[255:0] ← ARITHMETIC_RIGHT_SHIFT_DWORDS_256b(SRC1, imm8)
</pre>
<h2 id="intel-c-c---compiler-intrinsic-equivalents">Intel C/C++ Compiler Intrinsic Equivalents</h2>
<table>
<tr>
	<td>PSRAW:</td>
	<td>__m64 _mm_srai_pi16 (__m64 m, int count)</td>
</tr>
<tr>
	<td>PSRAW:</td>
	<td>__m64 _mm_sra_pi16 (__m64 m, __m64 count)</td>
</tr>
<tr>
	<td>(V)PSRAW:</td>
	<td>count)</td>
</tr>
<tr>
	<td>(V)PSRAW:</td>
	<td>__m128i _mm_sra_epi16(__m128i m, __m128i count)</td>
</tr>
<tr>
	<td>VPSRAW:</td>
	<td>__m256i _mm256_srai_epi16 (__m256i m, int count)</td>
</tr>
<tr>
	<td>VPSRAW:</td>
	<td>__m256i _mm256_sra_epi16 (__m256i m, __m128i count)</td>
</tr>
<tr>
	<td>PSRAD:</td>
	<td>__m64 _mm_srai_pi32 (__m64 m, int count)</td>
</tr>
<tr>
	<td>PSRAD:</td>
	<td>__m64 _mm_sra_pi32 (__m64 m, __m64 count)</td>
</tr>
<tr>
	<td>(V)PSRAD:</td>
	<td>count)</td>
</tr>
<tr>
	<td>(V)PSRAD:</td>
	<td>__m128i _mm_sra_epi32 (__m128i m, __m128i count)</td>
</tr>
<tr>
	<td>VPSRAD:</td>
	<td>__m256i _mm256_srai_epi32 (__m256i m, int count)</td>
</tr>
<tr>
	<td>VPSRAD:</td>
	<td>__m256i _mm256_sra_epi32 (__m256i m, __m128i count)</td>
</tr>
</table>
<h2 id="flags-affected">Flags Affected</h2>
<p>None.</p>
<h2 id="numeric-exceptions">Numeric Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 4 and 7 for non-VEX-encoded instructions; additionally</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.L = 1.</td>
</tr>
</table>
</body>
</html>
