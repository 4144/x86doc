<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>DIVSD—Divide Scalar Double-Precision Floating-Point Values</title>
</head>
<body>
<h1 id="divsd-divide-scalar-double-precision-floating-point-values">DIVSD—Divide Scalar Double-Precision Floating-Point Values</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32-bit Mode</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>F2 0F 5E /<em>r</em> DIVSD <em>xmm1</em>, <em>xmm2/m64</em></td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Divide low double-precision floating-point value in <em>xmm1</em> by low double-precision floating-point value in <em>xmm2/mem64.</em></td>
</tr>
<tr>
	<td>VEX.NDS.LIG.F2.0F.WIG 5E /r VDIVSD xmm1, xmm2, xmm3/m64</td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Divide low double-precision floating point values in xmm2 by low double precision floating-point value in xmm3/mem64.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (r, w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>RVM</td>
	<td>ModRM:reg (w)</td>
	<td>VEX.vvvv (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination hyperons are XMM registers. The high quadword of the destination operand is copied from the high quadword of the first source operand. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Devel<em>o</em>per’s Manual, Volume 1, for an overview of a scalar double-precision floating-point operation.</em></p>
<p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX1:64) of the corresponding YMM destination register remain unchanged. VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p>
<h2 id="operation">Operation</h2>
<pre>DIVSD (128-bit Legacy SSE version)
DEST[63:0] ← DEST[63:0] / SRC[63:0]
DEST[VLMAX-1:64] (Unmodified)
VDIVSD (VEX.128 encoded version)
DEST[63:0] ← SRC1[63:0] / SRC2[63:0]
DEST[127:64] ← SRC1[127:64]
DEST[VLMAX-1:128] ← 0
</pre>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>DIVSD:</td>
	<td>__m128d _mm_div_sd (m128d a, m128d b)</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>Overflow, Underflow, Invalid, Divide-by-Zero, Precision, Denormal.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 3.</p>
</body>
</html>
