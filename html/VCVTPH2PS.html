<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>VCVTPH2PS—Convert 16-bit FP Values to Single-Precision FP Values</title>
</head>
<body>
<h1 id="vcvtph2ps-convert-16-bit-fp-values-to-single-precision-fp-values">VCVTPH2PS—Convert 16-bit FP Values to Single-Precision FP Values</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32bit Mode</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>VEX.256.66.0F38.W0 13 /r VCVTPH2PS ymm1, xmm2/m128</td>
	<td>RM</td>
	<td>V/V</td>
	<td>F16C</td>
	<td>Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1.</td>
</tr>
<tr>
	<td>VEX.128.66.0F38.W0 13 /r VCVTPH2PS xmm1, xmm2/m64</td>
	<td>RM</td>
	<td>V/V</td>
	<td>F16C</td>
	<td>Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Converts four/eight packed half precision (16-bits) floating-point values in the low-order 64/128 bits of an XMM/YMM register or 64/128-bit memory location to four/eight packed single-precision floating-point values and writes the converted values into the destination XMM/YMM register. If case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR. 128-bit version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (VLMAX-1:128) of the corresponding destination YMM register are zeroed. 256-bit version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register. The diagram below illustrates how data is converted from four packed half precision (in 64 bits) to four single precision (in 128 bits) FP values. Note: VEX.vvvv is reserved (must be 1111b).</p>
<table>
<tr>
	<td>VCVTPH2PS xmm1, xmm2/mem64, 95 convert</td>
	<td>imm8 0 xmm2/mem64 convert convert</td>
</tr>
<tr>
	<td>95 VS2</td>
	<td>0 xmm1</td>
</tr>
<tr>
	<td>Figure 4-31.</td>
	<td>VCVTPH2PS (128-bit Version)</td>
</tr>
</table>
<h2 id="operation">Operation</h2>
<pre>vCvt_h2s(SRC1[15:0])
{
RETURN Cvt_Half_Precision_To_Single_Precision(SRC1[15:0]);
}
VCVTPH2PS (VEX.256 encoded version)
DEST[31:0] ←vCvt_h2s(SRC1[15:0]);
DEST[63:32] ←vCvt_h2s(SRC1[31:16]);
DEST[95:64] ←vCvt_h2s(SRC1[47:32]);
DEST[127:96] ←vCvt_h2s(SRC1[63:48]);
DEST[159:128] ←vCvt_h2s(SRC1[79:64]);
DEST[191:160] ←vCvt_h2s(SRC1[95:80]);
DEST[223:192] ←vCvt_h2s(SRC1[111:96]);
DEST[255:224] ←vCvt_h2s(SRC1[127:112]);
VCVTPH2PS (VEX.128 encoded version)
DEST[31:0] ←vCvt_h2s(SRC1[15:0]);
DEST[63:32] ←vCvt_h2s(SRC1[31:16]);
DEST[95:64] ←vCvt_h2s(SRC1[47:32]);
DEST[127:96] ←vCvt_h2s(SRC1[63:48]);
DEST[VLMAX-1:128] ←0
</pre>
<h2 id="flags-affected">Flags Affected</h2>
<p>None</p>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<p>__m128 _mm_cvtph_ps ( __m128i m1);</p>
<p>__m256 _mm256_cvtph_ps ( __m128i m1)</p>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>Invalid</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>Exceptions Type 11 (do not report #AC); additionally</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.W=1.</td>
</tr>
</table>
</body>
</html>
