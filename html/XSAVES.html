<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>XSAVES—Save Processor Extended States Supervisor</title>
</head>
<body>
<h1 id="xsaves-save-processor-extended-states-supervisor">XSAVES—Save Processor Extended States Supervisor</h1>
<table>
<tr>
	<td>Opcode</td>
	<td>Instruction</td>
	<td>Op/En</td>
	<td>64-Bit Mode</td>
	<td>Compat/Leg Mode</td>
	<td>Description</td>
</tr>
<tr>
	<td>0F C7 /5</td>
	<td>XSAVES mem</td>
	<td>M</td>
	<td>Valid</td>
	<td>Valid</td>
	<td>Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.</td>
</tr>
<tr>
	<td>REX.W+ 0F C7 /5</td>
	<td>XSAVES64 mem</td>
	<td>M</td>
	<td>Valid</td>
	<td>N.E.</td>
	<td>Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>M</td>
	<td>ModRM:r/m (w)</td>
	<td>NA</td>
	<td>NA</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logicalAND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.</p><p>The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.</p><p>Section 13.10, “Operation of XSAVES,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVES instruction. The following items provide a highlevel outline:</p><table>
<tr>
	<td>•••••Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</td>
	<td>Execution of XSAVES is similar to that of XSAVEC. XSAVES differs from XSAVEC in that it can save state components corresponding to bits set in the IA32_XSS MSR and that it may use the modified optimization. XSAVES saves state component i only if RFBM[i] = 1 and XINUSE[i] = 1.1 (XINUSE is a bitmap by which the processor tracks the status of various state components. See Section 13.5.4, “Processor Tracking of XSAVEManaged State.”) Even if both bits are 1, XSAVES may optimize and not save state component i if (1) state component i has not been modified since the last execution of XRTOR or XRSTORS; and (2) this execution of XSAVES correspond to that last execution of XRTOR or XRSTORS as determined by XRSTOR_INFO (see the Operation section below). XSAVES does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, “Legacy Region of an XSAVE Area”). XSAVES writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the XSAVE header.2 (See Section 13.4.2, “XSAVE Header.”) XSAVES sets bit 63 of the XCOMP_BV field and sets bits 62:0 of that field to RFBM[62:0]. XSAVES does not write to any parts of the XSAVE header other than the XSTATE_BV and XCOMP_BV fields. XSAVES always uses the compacted format of the extended region of the XSAVE area (see Section 13.4.3,“Extended Region of an XSAVE Area”).</td>
</tr>
<tr>
	<td>1.</td>
	<td>There is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, the init optimization does not apply and XSAVEC will save SSE state as long as RFBM[1] =1 and the modified optimization is not being applied.</td>
</tr>
<tr>
	<td>2.</td>
	<td>There is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, XSAVES sets XSTATE_BV[1] to 1 as long as RFBM[1] = 1.</td>
</tr>
</table>
<h2 id="operation">Operation</h2>
<pre>RFBM ← XCR0 AND EDX:EAX;
IF in VMX non-root operation
  THEN VMXNR ← 1;
  ELSE VMXNR ← 0;
FI;
LAXA ← linear address of XSAVE area;
COMPMASK ← RFBM OR 80000000_00000000H;
IF XRSTOR_INFO = CPL,VMXNR,LAXA,COMPMASK
  THEN MODOPT ← 1;
  ELSE MODOPT ← 0;
FI;
IF RFBM[0] = 1 and XINUSE[0] = 1
  THEN store x87 state into legacy region of XSAVE area;
  /* might avoid saving if x87 state is not modified and MODOPT = 1 */
FI;
IF RFBM[1] = 1 and (XINUSE[1] = 1 or MXCSR ≠ 1F80H)
  THEN store SSE state into legacy region of XSAVE area;
  /* might avoid saving if SSE state is not modified and MODOPT = 1 */
FI;
IF RFBM[2] = 1 AND XINUSE[2] = 1
  THEN store AVX state into extended region of XSAVE area;
  /* might avoid saving if AVX state is not modified and MODOPT = 1 */
FI;
XSTATE_BV field in XSAVE header ← XINUSE AND RFBM;
XCOMP_BV field in XSAVE header ← COMPMASK;
</pre><h2 id="flags-affected">Flags Affected</h2>
<p>None.</p><h2 id="intel-c-c---compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>XSAVES:</td>
	<td>void _xsaves( void * , unsigned __int64);</td>
</tr>
<tr>
	<td>XSAVES64:</td>
	<td>void _xsaves64( void * , unsigned __int64);</td>
</tr>
</table>
<h2 id="protected-mode-exceptions">Protected Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If a memory operand is not aligned on a 64-byte boundary, regardless of segment.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory operand effective address is outside the SS segment limit.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>If CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0. If CR4.OSXSAVE[bit 18] = 0. If any of the LOCK, 66H, F3H or F2H prefixes is used.</td>
</tr>
<tr>
	<td>#AC</td>
	<td>If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an align-</td>
</tr>
</table>
<p>ment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).</p><h2 id="real-address-mode-exceptions">Real-Address Mode Exceptions</h2>
<table>
<tr>
	<td>#GP</td>
	<td>If a memory operand is not aligned on a 64-byte boundary, regardless of segment. If any part of the operand lies outside the effective address space from 0 to FFFFH.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>If CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0. If CR4.OSXSAVE[bit 18] = 0. If any of the LOCK, 66H, F3H or F2H prefixes is used.</td>
</tr>
</table>
<h2 id="virtual-8086-mode-exceptions">Virtual-8086 Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p><h2 id="compatibility-mode-exceptions">Compatibility Mode Exceptions</h2>
<p>Same exceptions as in protected mode.</p><h2 id="64-bit-mode-exceptions">64-Bit Mode Exceptions</h2>
<table>
<tr>
	<td>#GP(0)</td>
	<td>If the memory address is in a non-canonical form. If a memory operand is not aligned on a 64-byte boundary, regardless of segment.</td>
</tr>
<tr>
	<td>#SS(0)</td>
	<td>If a memory address referencing the SS segment is in a non-canonical form.</td>
</tr>
<tr>
	<td>#PF(fault-code)</td>
	<td>If a page fault occurs.</td>
</tr>
<tr>
	<td>#NM</td>
	<td>If CR0.TS[bit 3] = 1.</td>
</tr>
<tr>
	<td>#UD</td>
	<td>If CPUID.01H:ECX.XSAVE[bit 26] = 0 or CPUID.(EAX=0DH,ECX=1):EAX.XSS[bit 3] = 0. If CR4.OSXSAVE[bit 18] = 0. If any of the LOCK, 66H, F3H or F2H prefixes is used.</td>
</tr>
<tr>
	<td>#AC</td>
	<td>If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).</td>
</tr>
</table>
</body>
</html>
