<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>PCMPISTRI — Packed Compare Implicit Length Strings, Return Index</title>
</head>
<body>
<h1 id="pcmpistri-packed-compare-implicit-length-strings-return-index">PCMPISTRI — Packed Compare Implicit Length Strings, Return Index</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32 bit Mode Support</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>66 0F 3A 63 /r imm8 PCMPISTRI xmm1, xmm2/m128, imm8</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE4_2</td>
	<td>Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.</td>
</tr>
<tr>
	<td>VEX.128.66.0F3A.WIG 63 /r ib VPCMPISTRI xmm1, xmm2/m128, imm8</td>
	<td>RM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.</td>
</tr>
</table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>imm8</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX.</p>
<table>
<tr>
	<td>Each string is represented by a single value. contains the data elements of the string (byte or word data). A byte/word is considered valid only if it has a lower index than the least significant null (The least significant null byte/word is also considered invalid.) The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8). Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:</td>
	<td>The value is an xmm (or possibly m128 for the second operand) which Each input byte/word is augmented with a</td>
</tr>
</table>
<p>CFlag - Reset if IntRes2 is equal to zero, set otherwise ZFlag - Set if any byte/word of xmm2/mem128 is null, reset otherwise SFlag - Set if any byte/word of xmm1 is null, reset otherwise OFlag -IntRes2[0]AFlag - Reset PFlag - Reset Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p>
<h2 id="effective-operand-size">Effective Operand Size</h2>
<table>
<tr>
	<td>Operating mode/size</td>
	<td>Operand1</td>
	<td>Operand 2</td>
	<td>Result</td>
</tr>
<tr>
	<td>16 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>ECX</td>
</tr>
<tr>
	<td>32 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>ECX</td>
</tr>
<tr>
	<td>64 bit</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>ECX</td>
</tr>
<tr>
	<td>64 bit + REX.W</td>
	<td>xmm</td>
	<td>xmm/m128</td>
	<td>RCX</td>
</tr>
</table>
<h2 id="intel-c-c-compiler-intrinsic-equivalent-for-returning-index">Intel C/C++ Compiler Intrinsic Equivalent For Returning Index</h2>
<table>
<tr>
	<td>int</td>
	<td>_mm_cmpistri (__m128i a, __m128i b, const int mode);</td>
</tr>
</table>
<h2 id="intel-c-c-compiler-intrinsics-for-reading-eflag-results">Intel C/C++ Compiler Intrinsics For Reading EFlag Results</h2>
<table>
<tr>
	<td>int</td>
	<td>_mm_cmpistra (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistrc (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistro (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistrs (__m128i a, __m128i b, const int mode);</td>
</tr>
<tr>
	<td>int</td>
	<td>_mm_cmpistrz (__m128i a, __m128i b, const int mode);</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>None.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 4; additionally, this instruction does not cause #GP if the memory operand is not aligned to 16 Byte boundary, and</p>
<table>
<tr>
	<td>#UD</td>
	<td>If VEX.L = 1. If VEX.vvvv != 1111B.</td>
</tr>
</table>
</body>
</html>
