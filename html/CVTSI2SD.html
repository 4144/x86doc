<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>CVTSI2SD—Convert Dword Integer to Scalar Double-Precision FP Value</title>
</head>
<body>
<h1 id="cvtsi2sd-convert-dword-integer-to-scalar-double-precision-fp-value">CVTSI2SD—Convert Dword Integer to Scalar Double-Precision FP Value</h1>
<table>
<tr>
	<td>Opcode/Instruction</td>
	<td>Op/En</td>
	<td>64/32-bit Mode</td>
	<td>CPUID Feature Flag</td>
	<td>Description</td>
</tr>
<tr>
	<td>F2 0F 2A /r</td>
	<td>RM</td>
	<td>V/V</td>
	<td>SSE2</td>
	<td>Convert one signed doubleword integer from CVTSI2SD xmm, r/m32 value in xmm.</td>
</tr>
<tr>
	<td>F2 REX.W 0F 2A /r</td>
	<td>RM</td>
	<td>V/N.E.</td>
	<td>SSE2</td>
	<td>Convert one signed quadword integer from CVTSI2SD xmm, r/m64 value in xmm.</td>
</tr>
<tr>
	<td>VEX.NDS.LIG.F2.0F.W0 2A /r</td>
	<td>RVM</td>
	<td>V/V</td>
	<td>AVX</td>
	<td>Convert one signed doubleword integer from VCVTSI2SD xmm1, xmm2, r/m32 value in xmm1.</td>
</tr>
<tr>
	<td>VEX.NDS.LIG.F2.0F.W1 2A /r</td>
	<td>RVM</td>
	<td>V/N.E.1</td>
	<td>AVX</td>
	<td>Convert one signed quadword integer from VCVTSI2SD xmm1, xmm2, r/m64 value in xmm1.</td>
</tr>
</table>
<p class="notes">Notes: 1. Encoding the VEX prefix with VEX.W=1 in non-64-bit mode is ignored.</p>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding</h2>
<table>
<tr>
	<td>Op/En</td>
	<td>Operand 1</td>
	<td>Operand 2</td>
	<td>Operand 3</td>
	<td>Operand 4</td>
</tr>
<tr>
	<td>RM</td>
	<td>ModRM:reg (w)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
	<td>NA</td>
</tr>
<tr>
	<td>RVM</td>
	<td>ModRM:reg (w)</td>
	<td>VEX.vvvv (r)</td>
	<td>ModRM:r/m (r)</td>
	<td>NA</td>
</tr>
</table>
<h2 id="description">Description</h2>
<p>Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the second source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the beginning of this section for encoding data and limits. The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. 128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged. VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p>
<h2 id="operation">Operation</h2>
<pre>CVTSI2SD
IF 64-Bit Mode And OperandSize = 64
THEN
  DEST[63:0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[63:0]);
ELSE
  DEST[63:0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[31:0]);
FI;
DEST[VLMAX-1:64] (Unmodified)
VCVTSI2SD
IF 64-Bit Mode And OperandSize = 64
THEN
  DEST[63:0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC2[63:0]);
ELSE
  DEST[63:0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC2[31:0]);
FI;
DEST[127:64] ← SRC1[127:64]
DEST[VLMAX-1:128] ← 0
</pre>
<h2 id="intel-c-c-compiler-intrinsic-equivalent">Intel C/C++ Compiler Intrinsic Equivalent</h2>
<table>
<tr>
	<td>CVTSI2SD:</td>
	<td>__m128d _mm_cvtsi32_sd(__m128d a, int b)</td>
</tr>
<tr>
	<td>CVTSI2SD:</td>
	<td>__m128d _mm_cvtsi64_sd(__m128d a, __int64 b)</td>
</tr>
</table>
<h2 id="simd-floating-point-exceptions">SIMD Floating-Point Exceptions</h2>
<p>Precision.</p>
<h2 id="other-exceptions">Other Exceptions</h2>
<p>See Exceptions Type 3.</p>
</body>
</html>
